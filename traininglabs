ignup

https://about.gitlab.com/

Create project

#On ubuntu system

git version

sudo apt install git

Lab2:

#ssh based authentication, from ubuntu terminal

ssh-keygen -t rsa

#Don't give file name and passprhase leave it blank and enter

cat /home/user/.ssh/id_rsa.pub

#Copy that key, and paste it -->gitlab-->prefrences-->sshkey

#Go to project-->code-->ssh url

git clone yoursshurl

Lab3:
git config --global user.name amit
git config --global user.email amit@ow.com
git config --global --list
touch abc
git status
git add abc
git status
git commit -m "Fixing code"
git status
git log
cat .git/config
git push origin main

#Go to gitlab.com and check for the file

Lab4:

git branch
git branch test
git checkout test
git branch
touch file
git add file
git commit -m "Add to branch"
git log
ls
git checkout main
ls
 git checkout test
 ls
 git push origin test
 

git checkout main
git merge test
git push origin main

Lab5

lab 4
https://github.com/amitopenwriteup/gitlab-training/blob/main/Lab%204.pdf


Lab 6:
gitlab.com--->project-->Setting-->merger request-->enable trails
#Create group
#Create project--->namespace-->group namespace

Lab7:
    

Exercise 5.1: Set Up Basic Approval Rules
Scenario: You need code review from at least 2 team members.
Tasks:

Navigate     to Approval rules 
Click     Add approval rule 
Configure:        
Name:      "Code Review"  
Approvals      required: 1
Eligible      approvers: Select team members  
Target      branches: main or All branches  
Save     the rule
Exercise 5.2: Configure Approval Settings
Tasks: Enable the following settings and test their effects:

Prevent     approval by merge request creator   

git clone <project>

git branch test
touch a
git add a
git commit -m "ad"
git push origin test
----------------------------

Project-->repo

Lab 8:
    
gitlab.com-->project

.gitlab-ci.yml

job1:
    script:
        - echo "hello"

#Your account must verified

#Same code you will place on self hosted, and check the message

#Create project runner for gitlab and selfhosted

.gitlab-ci.yml

job1:
    tags:
        - myrunner
    script: 
        - echo "hello"

#workaround runner for shell
sudo apt install vim -y
sudo vi /home/gitlab-runner/.bash_logout
#Comment all the lines
sudo gitlab-runner run

----------------
09/12

Lab1: 

.gitlab-ci.yml (gitlab.com)

image: debian:latest
stages:
  - prepare
  - test
  - deploy
before_script:
  - echo "Global setup starting..."
  - apt-get update -y
  - apt-get install -y curl
  - echo "Global setup done."
prepare-job:
  stage: prepare
  script:
    - echo "Preparing environment..."
unit-tests:
  stage: test
  script:
    - echo "Running unit tests..."
    - curl --version
integration-tests:
  stage: test
  script:
    - echo "Running integration tests..."
    - curl https://example.com
deploy-job:
  stage: deploy
  script:
    - echo "Deploying application..."


---selfhosted/custom runner

##shell runner
sudo apt install vim
sudo vim /etc/sudoers
gitlab-runner ALL=(ALL) NOPASSWD: ALL
#esc :wq!

stages:
  - prepare
  - test
  - deploy

before_script:
  - echo "Global setup starting..."
  - sudo apt-get update -y
  - sudo apt-get install -y curl
  - echo "Global setup done."
prepare-job:
  stage: prepare
  tags:
    - myrunner

  script:
    - echo "Preparing environment..."

unit-tests:
  stage: test
  tags:
    - myrunner
  script:
    - echo "Running unit tests..."
    - curl --version

integration-tests:
  stage: test
  tags:
    - myrunner
  script:
    - echo "Running integration tests..."
    - curl https://example.com

deploy-job:
  stage: deploy
  tags:
    - myrunner
  script:
    - echo "Deploying application..."


-------
stages:
  - prepare
  - test
  - deploy

default:
  tags:
    - myrunner

before_script:
  - echo "Global setup starting..."
  - sudo apt-get update -y
  - sudo apt-get install -y curl
  - echo "Global setup done."

prepare-job:
  stage: prepare
  script:
    - echo "Preparing environment..."

unit-tests:
  stage: test
  script:
    - echo "Running unit tests..."
    - curl --version

integration-tests:
  stage: test
  script:
    - echo "Running integration tests..."
    - curl https://example.com

deploy-job:
  stage: deploy
  script:
    - echo "Deploying application..."
    
#Register the docker runner

https://docs.docker.com/engine/install/ubuntu/
 
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc
 
# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
   sudo apt-get update
    
2.sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

sudo docker version

Create another project runner-->dockerrunner

Register runner-->on to the linux machine-->docker executor-->debian

Lab 4:

stages:
  - prepare
  - test
  - deploy
prepare-job:
  stage: prepare
  tags:
    - dockerrunner
  script:
    - echo "Preparing environment..."
unit-tests:
  stage: test
  tags:
    - shellrunner
  before_script:
    - echo "Shell runner specific setup..."
    - sudo apt-get update -y
    - sudo apt-get install -y curl
    - echo "Shell runner setup done."
  script:
    - echo "Running unit tests on shell runner..."
    - curl --version
integration-tests:
  stage: test
  tags:
    - dockerrunner
  before_script:
    - echo "Shell runner specific setup..."
    - apt-get update -y
    - apt-get install -y curl
    - echo "Shell runner setup done."    
  script:
    - echo "Running integration tests on docker runner..."
    - curl https://example.com
deploy-job:
  stage: deploy
  tags:
    - dockerrunner
  script:
    - echo "Deploying application on docker runner..."

Running Multiple Runners with Separate Config Files

By default, all runners use /etc/gitlab-runner/config.toml. To use separate configs, create multiple runner services.
 Create Multiple Runner Services (Linux/Ubuntu)
A) Shell Runner with Custom Config
1. Create config directory:
sudo mkdir -p /etc/gitlab-runner-shell
2. Install the service:
sudo gitlab-runner install \
  --service gitlab-runner-shell \
  --config /etc/gitlab-runner-shell/config.toml \
  --user gitlab-runner \
  --working-directory /home/gitlab-runner
3. Register the runner:
sudo gitlab-runner register \
  --config /etc/gitlab-runner-shell/config.toml \
  --non-interactive \
  --url "http://10.33.172.154" \
  --token "glrt-57Lz0xn_354tDQNxBjOZTm86MQpwOjE5dDNhZAp0OjMKdTpqNHB2cRg.01.1j1f3s3qp"\
  --executor "shell" \
  --description "shell-runner"
4. Start the service:
sudo gitlab-runner run --config /etc/gitlab-runner-shell/config.toml


B) Docker Runner with Custom Config
1. Create config directory:
sudo mkdir -p /etc/gitlab-runner-docker
2. Install the service:
sudo gitlab-runner install \
  --service gitlab-runner-docker \
  --config /etc/gitlab-runner-docker/config.toml \
  --user gitlab-runner \
  --working-directory /home/gitlab-runner
3. Register the runner:
sudo gitlab-runner register \
  --config /etc/gitlab-runner-docker/config.toml \
  --non-interactive \
  --url "https://gitlab.com/" \
  --token glrt-57Lz0xn_354tDQNxBjOZTm86MQpwOjE5dDNhZAp0OjMKdTpqNHB2cRg.01.1j1f3s3qp\
  --executor "docker" \
  --docker-image "alpine:latest" \
  --docker-privileged \
  --description "docker-runner" \
4. Start the service:
sudo gitlab-runner run --config /etc/gitlab-runner-docker/config.toml


 
Managing Your Runners
# List all runners
sudo gitlab-runner list
 
# Stop a specific service
sudo gitlab-runner stop --config /etc/gitlab-runner-shell/config.toml
 
# Restart a specific service
sudo gitlab-runner restart --config /etc/gitlab-runner-docker/config.toml
 
# Unregister a runner
sudo gitlab-runner unregister --config /etc/gitlab-runner-shell/config.toml --all-runners
 
# Uninstall a service
sudo gitlab-runner uninstall --service gitlab-runner-shell

#sample code

stages:
  - build
  - test
build-docker:
  stage: build
  tags:
    - docker
  script:
    - echo "Running in Docker container"
test-shell:
  stage: test
  tags:
    - shell
  script:
    - echo "Running on shell executor"
    - pwd
    - whoami

Lab(after_script)
stages:
  - hello
say-hello:
  stage: hello
  tags:
    - myrunner
  before_script:
    - sudo apt-get update -y
    - sudo apt-get install -y cowsay
  script:
    - /usr/games/cowsay "hello from GitLab CI" > output.txt
  artifacts:
    paths:
      - output.txt
    expire_in: 1 hour
  after_script:
    - apt-get remove -y cowsay 


Lab 7(gitlab.com)

image: debian:latest

stages:
  - prepare
  - test
  - deploy

before_script:
  - echo "Global setup starting..."
  - apt-get update -y
  - apt-get install -y curl
  - echo "Global setup done."
  - date

prepare-job:
  stage: prepare
  script:
    - echo "Preparing environment..."

unit-tests:
  stage: test
  script:
    - echo "Running unit tests..."
    - curl --version
    - echo "Oops, something went wrong"
    - exit 1 
  needs:
    - job: prepare-job

integration-tests:
  stage: test
  script:
    - echo "Running integration tests..."
    - curl https://example.com
  needs:
    - job: unit-tests

deploy-job:
  stage: deploy
  script:
    - echo "Deploying application..."
  needs:
    - job: integration-tests

-----------------
 
Import the project:
    
https://github.com/hellokaton/java11-examples.git
 
.gitlab-ci.yml (gitlab)

image: maven:3.9.6-eclipse-temurin-11
stages:
  - build
  - publish
build:
  stage: build
  script:
    - mvn clean package
  artifacts:
    paths:
      - target/*.jar
    expire_in: 1 hour
publish:
  stage: publish
  script:
    - echo "Publishing step placeholder. Add deployment or artifact upload here."


--------
gitlab-->

image: maven:3.9.6-eclipse-temurin-11

# Global variables
variables:
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"
  MAVEN_CLI_OPTS: "--batch-mode --errors --fail-at-end --show-version"
  APP_NAME: "my-java-app"
  APP_VERSION: "1.0.0"
  DEPLOY_ENV: "production"

stages:
  - build
  - publish

build:
  stage: build
  variables:
    BUILD_TYPE: "release"
  script:
    - echo "Building $APP_NAME version $APP_VERSION"
    - echo "Build type $BUILD_TYPE"
    - mvn $MAVEN_CLI_OPTS clean package
    - echo "Build completed for $CI_COMMIT_REF_NAME branch"
  artifacts:
    paths:
      - target/*.jar
    expire_in: 1 hour

publish:
  stage: publish
  variables:
    PUBLISH_TARGET: "nexus-repository"
  script:
    - echo "Publishing $APP_NAME to $DEPLOY_ENV environment"
    - echo "Target repository $PUBLISH_TARGET"
    - echo "Artifact $(ls target/*.jar)"
    - echo "GitLab CI Variables:"
    - echo "  - Project $CI_PROJECT_NAME"
    - echo "  - Branch $CI_COMMIT_REF_NAME"
    - echo "  - Commit $CI_COMMIT_SHORT_SHA"
    - echo "  - Pipeline ID $CI_PIPELINE_ID"
  when: manual

----------
image: maven:3.9.6-eclipse-temurin-11

# Global variables
variables:
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"
  MAVEN_CLI_OPTS: "--batch-mode --errors --fail-at-end --show-version"
  APP_NAME: "my-java-app"
  APP_VERSION: "1.0.0"
  DEPLOY_ENV: "production"
# Global before_script - runs before every job
before_script:
  - echo "========================================="
  - echo "Setting up environment..."
  - echo "========================================="
  - java -version
  - mvn -version
  - echo "Current directory $(pwd)"
  - echo "Installing additional tools..."
  - apt-get update -qq
  - apt-get install -y -qq curl git
  - echo "Environment setup complete!"
  - echo "========================================="
# Global after_script - runs after every job
after_script:
  - echo "========================================="
  - echo "Cleanup and post-job actions..."
  - echo "Job status $CI_JOB_STATUS"
  - echo "========================================="
stages:
  - build
  - publish
build:
  stage: build
  variables:
    BUILD_TYPE: "release"
  # Job-specific before_script (runs AFTER global before_script)
  script:
    - echo "Building $APP_NAME version $APP_VERSION"
    - echo "Build type $BUILD_TYPE"
    - echo "Java opts $JAVA_OPTS"
    - mvn $MAVEN_CLI_OPTS clean package
    - echo "Build completed for $CI_COMMIT_REF_NAME branch"
  # Job-specific after_script
  after_script:
    - echo "Build artifacts created:"
    - ls -lh target/ || echo "No target directory found"
  artifacts:
    paths:
      - target/*.jar
    expire_in: 1 hour
publish:
  stage: publish
  variables:
    PUBLISH_TARGET: "nexus-repository"
  # Override global before_script for this job
  script:
    - echo "Publishing $APP_NAME to $DEPLOY_ENV environment"
    - echo "Target repository $PUBLISH_TARGET"
    - echo "Artifact $(ls target/*.jar)"
    - echo "Deployed by $DEPLOY_USER"
    - echo "GitLab CI Variables:"
    - echo "  - Project $CI_PROJECT_NAME"
    - echo "  - Branch $CI_COMMIT_REF_NAME"
    - echo "  - Commit $CI_COMMIT_SHORT_SHA"
    - echo "  - Pipeline ID $CI_PIPELINE_ID"
  after_script:
    - echo "Publishing completed or failed"
    - echo "Sending notification..."
  when: manual
  
  -------------------------------------
image: maven:3.9.6-eclipse-temurin-11
# Global variables
variables:
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"
  MAVEN_CLI_OPTS: "--batch-mode --errors --fail-at-end --show-version"
  APP_NAME: "my-java-app"
  APP_VERSION: "1.0.0"
  DEPLOY_ENV: "production"
stages:
  - build
  - publish
build:
  stage: build
  variables:
    BUILD_TYPE: "release"
  script:
    - echo "Building $APP_NAME version $APP_VERSION"
    - echo "Build type $BUILD_TYPE"
    - mvn $MAVEN_CLI_OPTS clean package
    - echo "Build completed for $CI_COMMIT_REF_NAME branch"
  artifacts:
    paths:
      - target/*.jar
    expire_in: 1 hour
publish:
  stage: publish
  variables:
    PUBLISH_TARGET: "nexus-repository"
  script:
    - echo "Publishing $APP_NAME to $DEPLOY_ENV environment"
    - echo "Target repository $PUBLISH_TARGET"
    - echo "Artifact $(ls target/*.jar)"
    - echo "GitLab CI Variables:"
    - echo "  - Project $CI_PROJECT_NAME"
    - echo "  - Branch $CI_COMMIT_REF_NAME"
    - echo "  - Commit $CI_COMMIT_SHORT_SHA"
    - echo "  - Pipeline ID $CI_PIPELINE_ID"
  rules:
    # Run manually on main branch when build succeeds
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    # Never run on other branches
    - when: never
  needs:
    - job: build
      artifacts: true
      
--------------------------


-------------------------------------
image: maven:3.9.6-eclipse-temurin-11
.default_base:
  before_script:
    - echo "========================================="
    - echo "Setting up environment..."
    - echo "========================================="
    - java -version
    - mvn -version
    - echo "Current directory $(pwd)"
    - echo "Installing additional tools..."
    - apt-get update -qq
    - apt-get install -y -qq curl git
    - echo "Environment setup complete!"
    - echo "========================================="
  after_script:
    - echo "========================================="
    - echo "Cleanup and post-job actions..."
    - echo "Job status $CI_JOB_STATUS"
    - echo "========================================="
variables:
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"
  MAVEN_CLI_OPTS: "--batch-mode --errors --fail-at-end --show-version"
  APP_NAME: "my-java-app"
  APP_VERSION: "1.0.0"
  DEPLOY_ENV: "production"
stages:
  - build
  - publish
build:
  extends: .default_base
  stage: build
  variables:
    BUILD_TYPE: "release"
  before_script:
    - !reference [.default_base, before_script]
    - echo "Build-specific setup..."
    - mkdir -p target
    - echo "Setting Java memory options..."
    - export JAVA_OPTS="-Xmx1024m -Xms512m"
  script:
    - echo "Building $APP_NAME version $APP_VERSION"
    - mvn $MAVEN_CLI_OPTS clean package
  artifacts:
    paths:
      - target/*.jar
    expire_in: 1 hour
publish:
  extends: .default_base
  stage: publish
  variables:
    PUBLISH_TARGET: "nexus-repository"
  before_script:
    - !reference [.default_base, before_script]
    - echo "Publish-specific setup..."
    - apt-get install -y -qq jq
    - ls -lh target/*.jar
  script:
    - echo "Publishing $APP_NAME to $DEPLOY_ENV environment"
    - echo "Artifact $(ls target/*.jar)"
  when: manual
  
  ---------------
  
  default:
      tags:
          - dockerrunner
      image: maven:3.9.6-eclipse-temurin-11


-------------
default:
  tags:
    - docker
  image: maven:3.9.6-eclipse-temurin-11
.default_base:
  before_script:
    - echo "========================================="
    - echo "Setting up environment..."
    - echo "========================================="
    - java -version
    - mvn -version
    - echo "Current directory $(pwd)"
    - echo "Installing additional tools..."
    - apt-get update -qq
    - apt-get install -y -qq curl git
    - echo "Environment setup complete!"
    - echo "========================================="
  after_script:
    - echo "========================================="
    - echo "Cleanup and post-job actions..."
    - echo "Job status $CI_JOB_STATUS"
    - echo "========================================="
variables:
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"
  MAVEN_CLI_OPTS: "--batch-mode --errors --fail-at-end --show-version"
  APP_NAME: "my-java-app"
  APP_VERSION: "1.0.0"
  DEPLOY_ENV: "production"
stages:
  - build
  - publish
build:
  extends: .default_base
  stage: build
  variables:
    BUILD_TYPE: "release"
  before_script:
    - !reference [.default_base, before_script]
    - echo "Build-specific setup..."
    - mkdir -p target
    - echo "Setting Java memory options..."
    - export JAVA_OPTS="-Xmx1024m -Xms512m"
  script:
    - echo "Building $APP_NAME version $APP_VERSION"
    - mvn $MAVEN_CLI_OPTS clean package
  artifacts:
    paths:
      - target/*.jar
    expire_in: 1 hour
publish:
  extends: .default_base
  stage: publish
  variables:
    PUBLISH_TARGET: "nexus-repository"
  before_script:
    - !reference [.default_base, before_script]
    - echo "Publish-specific setup..."
    - apt-get install -y -qq jq
    - ls -lh target/*.jar
  script:
    - echo "Publishing $APP_NAME to $DEPLOY_ENV environment"
    - echo "Artifact $(ls target/*.jar)"
  when: manual

---------------
[gitlab]


------------------

# Reusable CI/CD templates
.default_base:
  before_script:
    - echo "========================================="
    - echo "Setting up environment..."
    - echo "========================================="
    - java -version
    - mvn -version
    - echo "Current directory $(pwd)"
    - echo "Installing additional tools..."
    - apt-get update -qq
    - apt-get install -y -qq curl git
    - echo "Environment setup complete!"
    - echo "========================================="
  after_script:
    - echo "========================================="
    - echo "Cleanup and post-job actions..."
    - echo "Job status $CI_JOB_STATUS"
    - echo "========================================="


---------------------------------------------------
10/12

Lab1:
Create a new project: cicd [gitlab.com]
 
1) Create a python file: app.py
 
from flask import Flask
app = Flask(__name__)
@app.route('/')
def hello_world():
    return 'Hello, World!'
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0',port=8080)
 
2) Create a dockerfile: dockerfile
 
FROM python:3.9-alpine
WORKDIR /flask_app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
RUN pip install pytest
EXPOSE 8080
COPY app.py .
CMD [ "python", "app.py" ]
 
3) Create a requirements.txt file
 
Flask==3.1.0
 
4) Create PAT
 
On the left sidebar, select your avatar.
 
Select Edit profile.
 
On the left sidebar, select Access tokens.
 
Select Add new token.
 
In Token name, enter a name for the token.
 
Optional. In Token description, enter a description for the token.
 
In Expiration date, enter an expiration date for the token.
 
 
Select the desired scopes.api, read and write registry
 
Select Create personal access token.
 
5)Reminder for GitLab CI/CD Variables:
Go to Project Settings > CI/CD > Variables and add:
 
Key        Value
CI_REGISTRY_USER        Your GitLab username
CI_REGISTRY_PASSWORD        Your GitLab personal access token with api and readm write_registry scopes

Registry info;

Deploy-->container registry-->get the path
 
4) now create a .gitlab-ci.yml file build the package and publish to GitLab registry
 
stages:
  - build
 
variables:
  DOCKERFILE: "dockerfile"      # Dockerfile path
  REGISTRY: "registry.gitlab.com/tejipatil14-group/cicd" # GitLab registry
  IMAGE_NAME: "myimage"
  IMAGE_TAG: "latest"
  DOCKER_HOST: tcp://docker:2375/
  DOCKER_TLS_CERTDIR: ""
 
build_docker_image:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - echo "Logging into Docker registry..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login registry.gitlab.com -u "$CI_REGISTRY_USER" --password-stdin
  script:
    - echo "Building Docker image..."
    - docker build -f $DOCKERFILE -t $REGISTRY/$IMAGE_NAME:$IMAGE_TAG .
    - docker push $REGISTRY/$IMAGE_NAME:$IMAGE_TAG
  only:
    - main


Lab2: Self hosted

Create a new repo: cicd
 
1) Create a python file: app.py
 
from flask import Flask
app = Flask(__name__)
@app.route('/')
def hello_world():
    return 'Hello, World!'
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0',port=8080)
 
2) Create a dockerfile: dockerfile
 
FROM python:3.9-alpine
WORKDIR /flask_app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
RUN pip install pytest
EXPOSE 8080
COPY app.py .
CMD [ "python", "app.py" ]
 
3) Create a requirements.txt file
 
Flask==3.1.0
 
 4)
 sudo docker run -d -p 5000:5000 --restart=always --name registry registry:2

5) create .gitlab-ci.yml
# GitLab CI/CD Pipeline for Shell Runner
# This pipeline builds a Docker image from the repository

variables:
  DOCKERFILE: "dockerfile"
  REGISTRY: "localhost:5000"
  IMAGE_NAME: "myimage"
  IMAGE_TAG: "latest"

stages:
  - build

# Build and push Docker image
build_docker_image:
  stage: build
  tags:
    - myrunner
  script:
    - echo "Building Docker image..."
    - sudo docker build -f ${DOCKERFILE} -t ${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG} .
    - echo "Pushing Docker image to registry..."
    - sudo docker push ${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}
  only:
    - main

6)#Test the image is created
docker pull localhost:5000/myimage:latest

http://localhost:5000/v2/_catalog

Lab3 and Lab 4

.gitlab-ci.yml-->gitlab.com
ecr.aws/docker/library/python:3.9-alpine

stages:
  - build
  - scan
variables:
  IMAGE_TAG: "latest"
  IMAGE_NAME: "$CI_REGISTRY_IMAGE:$IMAGE_TAG"
# Step 1: Build and push image
docker_build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
  script:
    - sudo docker build -t "$IMAGE_NAME" .
    - sudo docker push "$IMAGE_NAME"
# Step 2: Trivy scan (remote image, no Docker required here)
trivy_scan:
  stage: scan
  image: docker:latest
  before_script:
    - apk add --no-cache curl bash
    - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
    - echo "$CI_JOB_TOKEN" | docker login -u gitlab-ci-token --password-stdin "$CI_REGISTRY"
  script:
    - trivy image  "$IMAGE_NAME"


Lab4:(selfhosted)
    

variables:
  DOCKERFILE: "dockerfile"
  REGISTRY: "localhost:5000"
  IMAGE_NAME: "myimage"
  IMAGE_TAG: "latest"
  FULL_IMAGE_NAME: "${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"

stages:
  - build
  - scan

# Build and push Docker image 
build_docker_image:
  stage: build
  tags:
    - myrunner
  script:
    - echo "Building Docker image..."
    - docker build -f ${DOCKERFILE} -t ${FULL_IMAGE_NAME} .
    - echo "Pushing Docker image to registry..."
    - docker push ${FULL_IMAGE_NAME}
  only:
    - main
# Trivy vulnerability scan
trivy_scan:
  stage: scan
  tags:
    - myrunner
  before_script:
    - echo "Installing Trivy..."
    -  sudo apt-get install curl -y
    - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
  script:
    - echo "Scanning Docker image for vulnerabilities..."
    - trivy image --severity HIGH,CRITICAL ${FULL_IMAGE_NAME}
  allow_failure: true
  only:
    - main
    
    Lab4: Try Lab2 on docker runner

#setup k8s

sudo su 
 
#!/bin/bash
# For AMD64 / x86_64
[ $(uname -m) = x86_64 ] && curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
chmod +x ./kind
sudo cp ./kind /usr/local/bin/kind
rm -rf kind
 
vi config.yaml
#copy and paste below lines in config.yaml till line 645
# 4 node (3 workers) cluster config
# 4 node (3 workers) cluster config
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4

# Add registry config here
containerdConfigPatches:
- |-
  [plugins."io.containerd.grpc.v1.cri".registry.mirrors."10.32.2.55:5000"]
    endpoint = ["http://10.32.2.55:5000"]
nodes:
# Control-plane node
- role: control-plane
  image: kindest/node:v1.28.0
# Worker 1
- role: worker
  image: kindest/node:v1.28.0
# Worker 2
- role: worker
  image: kindest/node:v1.28.0
# Worker 3
- role: worker
  image: kindest/node:v1.28.0

 
kind create cluster --config=config.yaml
 
sudo mkdir -p -m 755 /etc/apt/keyrings
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list
apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
 
 
kubectl get nodes

1) Generate token : Where your k8s cluster setup
base64 ~/.kube/config | tr -d '\n'
2) Upload to setting-->cicd-->variable
key: KUBECONFIG_CONTENT
value: copy step1 value

Create a repo directory : k8s
vi deployment.yml
 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: java-app
  labels:
    app: java-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: java-app
  template:
    metadata:
      labels:
        app: java-app
    spec:
      containers:
        - name: java-app-container
          image: ${IMAGE_NAME}
          ports:
            - containerPort: 8080
          imagePullPolicy: Always
    

.gitlab-ci.yml

variables:
  DOCKERFILE: "dockerfile"
  REGISTRY: "10.33.173.111:5000"
  IMAGE_NAME: "myimage"
  IMAGE_TAG: "latest"
  FULL_IMAGE_NAME: "${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"
  KUBE_NAMESPACE: "default"
  DEPLOYMENT_FILE: "k8s/deployment.yml"
stages:
  - build
  - scan
  - deploy
# Build and push Docker image
build_docker_image:
  tags:
    - test
  variables:
    DOCKER_HOST: "tcp://docker:2375"
    DOCKER_TLS_CERTDIR: ""
    REGISTRY_URL: "localhost:5000"
    FULL_IMAGE_NAME: "${REGISTRY_URL}/myimage"
  script:
    - echo "Building Docker image..."
    - docker build -f ${DOCKERFILE} -t ${FULL_IMAGE_NAME} .
    - echo "Pushing Docker image to registry..."
    - docker push ${FULL_IMAGE_NAME}
  only:
    - main
# Trivy vulnerability scan
trivy_scan:
  stage: scan
  tags:
    - shared
  before_script:
    - echo "Installing Trivy..."
    - sudo curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
  script:
    - echo "Scanning Docker image for vulnerabilities..."
    - sudo trivy image --severity HIGH,CRITICAL ${FULL_IMAGE_NAME}
  allow_failure: true
  only:
    - main
# Deploy to Kubernetes
deploy_to_kubernetes:
  stage: deploy
  image: bitnami/kubectl:latest
  tags:
    - test
  before_script:
    - echo "Configuring kubectl..."
    - mkdir -p ~/.kube
    - echo "${KUBECONFIG_CONTENT}" | base64 -d > ~/.kube/config
    - kubectl version --client
  script:
    - echo "Deploying to Kubernetes namespace ${KUBE_NAMESPACE}..."
    - echo "Replacing image name in deployment file..."
    - sed -i "s|\${IMAGE_NAME}|${FULL_IMAGE_NAME}|g" ${DEPLOYMENT_FILE}
    - cat ${DEPLOYMENT_FILE}
    - kubectl apply -f ${DEPLOYMENT_FILE} -n ${KUBE_NAMESPACE}
    - echo "Deployment completed successfully!"
    - kubectl get pods -n ${KUBE_NAMESPACE} -l app=java-app
  only:
    - main
    
---------------

image: maven:3.9.6-eclipse-temurin-11
stages:
  - build
  - sonarcloud
  - publish
variables:
  SONAR_PROJECT_KEY: "amitow1234_test"
  SONAR_ORGANIZATION: "amitopenwriteup"
  SONAR_TOKEN: ""
  SONAR_HOST_URL: "https://sonarcloud.io"
build:
  stage: build
  script:
    - mvn clean package
  artifacts:
    paths:
      - target/
      - src/
    expire_in: 1 hour
sonar_scan:
  stage: sonarcloud
  image: ubuntu:22.04
  before_script:
    - apt-get update && apt-get install -y unzip wget openjdk-11-jdk
    - wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip
    - unzip sonar-scanner-cli-5.0.1.3006-linux.zip
  script:
    - ./sonar-scanner-5.0.1.3006-linux/bin/sonar-scanner
        -Dsonar.projectKey=$SONAR_PROJECT_KEY
        -Dsonar.organization=$SONAR_ORGANIZATION
        -Dsonar.qualitygate.wait=true
        -Dsonar.qualitygate.timeout=300
        -Dsonar.sources=src/main/java/
        -Dsonar.java.binaries=target/classes
        -Dsonar.host.url=$SONAR_HOST_URL
        -Dsonar.login=$SONAR_TOKEN
publish:
  stage: publish
  script:
    - echo "Publishing step placeholder. Add deployment or artifact upload here."


https://github.com/amitopenwriteup/gitlab-ci/blob/main/Sonar%20Setup.docx

https://github.com/amitopenwriteup/gitlab-ci/blob/main/Sonar%20Setup.pdf


# Parent Pipeline (.gitlab-ci.yml in main project)
stages:
  - build
  - test
  - trigger

build_job:
  stage: build
  script:
    - echo "Building the application"
    - mkdir -p build
    - echo "Build artifacts" > build/app.txt
  artifacts:
    paths:
      - build/
test_job:
  stage: test
  script:
    - echo "Running tests"
    - cat build/app.txt
# Trigger downstream pipeline in another project
trigger_downstream:
  stage: trigger
  trigger:
    project: your-group/downstream-project
    branch: main
    strategy: depend  # Wait for downstream pipeline to complete
  variables:
    PARENT_PIPELINE_ID: $CI_PIPELINE_ID
    ENVIRONMENT: "production"

# Alternative: Trigger with multi-project pipeline (optional)
trigger_multiple:
  stage: trigger
  trigger:
    project: your-group/another-project
    branch: develop
  only:
    - main

---
# Downstream Pipeline (.gitlab-ci.yml in downstream project)
stages:
  - prepare
  - deploy
prepare_downstream:
  stage: prepare
  script:
    - echo "Downstream pipeline triggered"
    - echo "Parent pipeline ID: $PARENT_PIPELINE_ID"
    - echo "Environment: $ENVIRONMENT"
deploy_downstream:
  stage: deploy
  script:
    - echo "Deploying from downstream pipeline"
    - echo "Using variables from parent"
  environment:
    name: $ENVIRONMENT
----------------

.gitlab-ci.yml

variables:
  DOCKERFILE: "dockerfile"
  REGISTRY: "10.33.173.111:5000"
  IMAGE_NAME: "myimage"
  IMAGE_TAG: "latest"
  FULL_IMAGE_NAME: "${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"
  KUBE_NAMESPACE: "default"
  DEPLOYMENT_FILE: "k8s/deployment.yml"
stages:
  - build
  - scan
  - deploy
# Build and push Docker image
build_docker_image:
  tags:
    - shell
  variables:
    DOCKER_HOST: "tcp://docker:2375"
    DOCKER_TLS_CERTDIR: ""
    REGISTRY_URL: "localhost:5000"
    FULL_IMAGE_NAME: "${REGISTRY_URL}/myimage"
  script:
    - echo "Building Docker image..."
    - docker build -f ${DOCKERFILE} -t ${FULL_IMAGE_NAME} .
    - echo "Pushing Docker image to registry..."
    - docker push ${FULL_IMAGE_NAME}
  only:
    - main
# Trivy vulnerability scan
trivy_scan:
  stage: scan
  tags:
    - shell
  before_script:
    - echo "Installing Trivy..."
    - sudo curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
  script:
    - echo "Scanning Docker image for vulnerabilities..."
    - sudo trivy image --severity HIGH,CRITICAL ${FULL_IMAGE_NAME}
  allow_failure: true
  only:
    - main
# Deploy to Kubernetes
#trigger_job:
 # trigger:
  #  include:
   #   - local: path/to/child-pipeline.yml
deploy_to_kubernetes:
  stage: deploy
  image: bitnami/kubectl:latest
  tags:
    - shell
  before_script:
    - echo "Configuring kubectl..."
    - mkdir -p ~/.kube
    - echo "${KUBECONFIG_CONTENT}" | base64 -d > ~/.kube/config
    - kubectl version --client
  script:
    - echo "Deploying to Kubernetes namespace ${KUBE_NAMESPACE}..."
    - echo "Replacing image name in deployment file..."
    - sed -i "s|\${IMAGE_NAME}|${FULL_IMAGE_NAME}|g" ${DEPLOYMENT_FILE}
    - cat ${DEPLOYMENT_FILE}
    - kubectl apply -f ${DEPLOYMENT_FILE} -n ${KUBE_NAMESPACE}
    - echo "Deployment completed successfully!"
    - kubectl get pods -n ${KUBE_NAMESPACE} -l app=java-app
  only:
    - main
    
    
    ------------------
    solutions

variables:
  DOCKERFILE: "dockerfile"
  REGISTRY: "10.33.173.111:5000"
  IMAGE_NAME: "myimage"
  IMAGE_TAG: "latest"
  FULL_IMAGE_NAME: "${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"
  KUBE_NAMESPACE: "default"
  DEPLOYMENT_FILE: "k8s/deployment.yml"

stages:
  - build
  - scan
  - trigger

# Build and push Docker image
build_docker_image:
  stage: build
  tags:
    - shell
  variables:
    DOCKER_HOST: "tcp://docker:2375"
    DOCKER_TLS_CERTDIR: ""
  script:
    - echo "Building Docker image..."
    - docker build -f ${DOCKERFILE} -t ${FULL_IMAGE_NAME} .
    - echo "Pushing Docker image to registry..."
    - docker push ${FULL_IMAGE_NAME}
  only:
    - main

# Trivy vulnerability scan
trivy_scan:
  stage: scan
  tags:
    - shell
  before_script:
    - echo "Installing Trivy..."
    - sudo curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
  script:
    - echo "Scanning Docker image for vulnerabilities..."
    - sudo trivy image --severity HIGH,CRITICAL ${FULL_IMAGE_NAME}
  allow_failure: true
  only:
    - main

# Trigger child pipeline for deployment
trigger_deploy_pipeline:
  stage: trigger
  trigger:
    include:
      - local: .gitlab-ci-deploy.yml
    strategy: depend
  only:
    - main
    

------------------
.gitlab-ci-deploy.yml

stages:
  - deploy

# Deploy to Kubernetes
deploy_to_kubernetes:
  stage: deploy
  image: bitnami/kubectl:latest
  tags:
    - shell
  before_script:
    - echo "Configuring kubectl..."
    - mkdir -p ~/.kube
    - echo "${KUBECONFIG_CONTENT}" | base64 -d > ~/.kube/config
    - kubectl version --client
  script:
    - echo "Deploying to Kubernetes namespace ${KUBE_NAMESPACE}..."
    - echo "Using image: ${FULL_IMAGE_NAME}"
    - echo "Replacing image name in deployment file..."
    - sed -i "s|\${IMAGE_NAME}|${FULL_IMAGE_NAME}|g" ${DEPLOYMENT_FILE}
    - cat ${DEPLOYMENT_FILE}
    - kubectl apply -f ${DEPLOYMENT_FILE} -n ${KUBE_NAMESPACE}
    - echo "Deployment completed successfully!"
    - kubectl get pods -n ${KUBE_NAMESPACE} -l app=java-app
  only:
    - main
